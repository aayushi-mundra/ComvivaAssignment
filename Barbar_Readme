1) Here we have two resources 
	1.1) Waiting room with <n> chairs
	1.2) Barber

2) I have used Synchronized method with wait and notify.
   2.1) Data structure for waiting customers -> Queue. The customer who came first should be served first.
   2.2) If there are no customers barber will sleep and wait for customers.
   2.3) If any customer arrives notify will be invoked on the <queue> and barbar will pick customer from the queue.
   2.4) There are two tasks here -> cutHair and acquireSeat
   
3) Design Part
   3.1) Entity : 
   		3.1.1) Barbar -> assignment.ques1.entity.Barbar, to store <Barbar's> info.
   		3.1.2) BarbarShop -> assignment.ques1.entity.BarbarShop, to store <BarbarShop's> info like <chair capacity> etc
   		3.1.3) Customer -> assignment.ques1.entity.Customer, to store <Customer's> info like <customerNumber> etc
   3.2) Threads : 
   		3.2.1) BarbarTask -> assignment.ques1.task.BarbarTask, Barbar Thread. 
   							This is a singleton class. According to requirements only one barbar will be serving all the customers.
   							This thread invokes <cutHair> process.
   		3.2.2) CustomerTask -> assignment.ques1.task.CustomerTask, Customer Thread. 
   							This thread invokes <acquireSeat> process.
   3.3) Service
   		3.3.1) BarbarShopService : assignment.ques1.service.BarbarShopService.
   							This is also a singleton class. According to requirements only one barbarShop is there.
   							Here <cutHair> and <acquireSeat> process are defined.
   							A queue of customer tasks is also maintained.
   							Any new customer coming will be a separate process and that will be added to <queue>.
   							<AtomicBoolean> is used to check if the barbar is occupied or not.
   							
   	3.4) BarbarShopTest : assignment.ques1.test.BarbarShopTest. JUnit test class.
   	3.5) BarberShopImpl : assignment.ques1.BarberShopImpl, Class which contains <main> method.
   						  Here I have used ExecutorService with FixedThreadPool to maintain Barbar and Customer Tasks.
   								
